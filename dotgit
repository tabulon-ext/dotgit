#!/usr/bin/env python3

import argparse
import os
import socket
import sys
import json
import subprocess
import shutil
import filecmp
from pathlib import Path

home = os.environ['HOME']
filelist = 'filelist'
dotfiles = 'dotfiles'

class Git:
    def __init__(self):
        pass

    def run(self, cmd):
        try:
            subprocess.run(cmd, check=True, capture_output=True)
        except subprocess.CalledProcessError as cp:
            log('command', cmd, 'failed, output:\n',
                    cp.stderr.decode(), level=0)
            sys.exit(1)

    def init(self):
        log('git initing')
        self.run(['git', 'init'])

    def add(self, fname):
        log('git adding', fname)
        self.run(['git', 'add', fname])

    def commit(self, msg):
        log('git committing "{}"'.format(msg))
        self.run(['git', 'commit', '-m', msg])

class FileOperations:
    def __init__(self):
        self.operations = []

    def makedirs(self, path):
        path = os.path.dirname(path)
        if not os.path.isdir(path):
            if os.path.isfile(path):
                self.rm(path)
            self.operations.append(('d', path))

    def samefile(self, src, dest, allow_link=False):
        if os.path.isfile(src) and os.path.isfile(dest):
            if allow_link:
                if os.path.samefile(dest, src):
                    return True
            elif not os.path.islink(dest) and filecmp.cmp(src, dest):
                    return True
            self.rm(dest)
        return False

    def copy(self, src, dest):
        self.makedirs(dest)
        if not self.samefile(src, dest):
            self.operations.append(('c', src, dest))

    def move(self, src, dest):
        self.makedirs(dest)
        if not self.samefile(src, dest):
            self.operations.append(('m', src, dest))

    def home_move(self, src, dest):
        if args.hard:
            self.copy(src, dest)
        else:
            self.move(src, dest)

    def link(self, src, dest):
        self.makedirs(dest)
        if not self.samefile(src, dest, allow_link=True):
            src = os.path.relpath(src, os.path.dirname(dest))
            self.operations.append(('l', src, dest))

    def home_link(self, src, dest):
        if args.hard:
            self.copy(src, dest)
        else:
            self.link(src, dest)

    def rm(self, src):
        self.operations.append(('r', src))

    def print_op(self, op, *args):
        if op == 'c':
            log('COPY:', args[0], '=>', args[1], level=1)
        elif op == 'm':
            log('MOVE:', args[0], '=>', args[1], level=1)
        elif op == 'l':
            log('LINK:', args[1], '=>', args[0], level=1)
        elif op == 'd':
            log('MKDIR:', args[0], level=1)
        elif op == 'r':
            log('DELETE:', args[0], level=1)

    def run_operations(self):
        # remove duplicate makedirs
        dirs = []
        nops = []
        for op in self.operations:
            if op[0] == 'd':
                if op[1] in dirs:
                    continue
                dirs.append(op[1])
            nops.append(op)
        self.operations = nops
        del dirs
        del nops

        if args.dry_run:
            log('dry-run, not executing any operations', level=1)
            for op in self.operations:
                self.print_op(*op)
            return

        for op in self.operations:
            self.print_op(*op)
            op, files = op[0], op[1:]

            if op == 'c':
                shutil.copy(files[0], files[1])
            elif op == 'm':
                shutil.move(files[0], files[1])
            elif op == 'l':
                os.symlink(files[0], files[1])
            elif op == 'd':
                os.makedirs(files[0])
            elif op == 'r':
                os.remove(files[0])

# level 0: errors
# level 1: informational
# level 2: debug
# level 3: variables
def log(*msg, level=2, pretty=False):
    global args

    # prettify dicts
    if pretty:
        msg = list(msg)
        for i in range(len(msg)):
            if type(msg[i]) in [dict, list]:
                msg[i] = json.dumps(msg[i], sort_keys=True, indent=1)

    if level == 0:
        print("ERROR:", *msg, file=sys.stderr)
    elif level <= args.verbose:
        print(*msg)

def prompt(question, default=True):
    if not question.endswith('?'):
        question += '?'
    opt = "[Yn]" if default else "[Ny]"

    while True:
        res = input(f"{question} {opt} ").lower()
        if not res:
            res = 'y' if default else 'n'

        if res == 'yes' or res == 'y':
            return True
        if res == 'no' or res == 'n':
            return False

        print('invalid input, please enter "y" or "n"')

def initialize_repo():
    '''makes the current dir a dotgit repo'''

    log('initializing dotgit repo')

    git.init()
    with open(filelist, 'a') as f:
        pass

    git.add(filelist)
    git.commit('initial dotgit commit')

def safety_checks():
    '''runs various startup safety checks.

    will call sys.exit(1) if a problem is found.
    '''

    log('running safety checks')

    if os.getcwd() == home:
        log('refusing to run dotgit in your home directory, aborting', level=0)
        sys.exit(1)

    if not os.path.isdir('.git'):
        log('this does not appear to be a git repo, aborting', level=0)
        sys.exit(1)

    if not os.path.isfile(filelist):
        log('cannot find filelist, aborting', level=0)
        sys.exit(1)

    if not os.path.isdir(dotfiles):
        try:
            os.makedirs(dotfiles)
        except OSError:
            log('cannot create dotfiles directory, aborting', level=0)
            sys.exit(1)

def parse_filelist(flist):
    '''parses the filelist
    :param flist: the filelist path
    :returns: a tuple (files, groups)
    '''

    log('parsing filelist')

    files = {}
    groups = {}

    with open(flist, 'r') as f:
        lines = f.readlines()

        for line in lines:
            line = line.strip()
            if not line:
                continue
            if line.startswith('#'):
                continue

            if ':' in line:
                fname, cat = line.split(':')
                cat = sorted(cat.split(','))
                files[fname] = files.get(fname, []) + [cat]
            elif '=' in line:
                group, cat = line.split('=')
                cat = sorted(cat.split(','))
                groups[group] = cat
            else:
                files[line] = files.get(line, []) + [['common']]

    log('filelist', filelist, 'parsed')
    log('({}) files:'.format(filelist), files, pretty=True, level=3)
    log('({}) groups:'.format(filelist), groups, pretty=True, level=3)
    return files, groups

def active_files(files, selected, groups):
    """determines the active files

    :param files: all the files in the filelist
    :param selected: the selected categories as they come from the program
    arguments
    :param groups: the groups as defined in the filelist
    :returns: a dict of the active files
    """

    log('determining active files')

    if not type(selected) is list:
        selected = [selected]

    # expand groups
    selected = [groups.get(s, [s]) for s in selected]
    selected = [i for j in selected for i in j]

    # remove duplicates and make set
    selected = set(selected)

    # find intersection between selected and available categories
    active = {f: [c for c in files[f] if set(c) & selected] for f in files}

    # remove empty files (not selected)
    active = {f: active[f] for f in active if active[f]}

    # check for conflicting activated categories
    if sum([len(active[f])-1 for f in active]):
        log('conflicting categories for files activated, offending filenames:',
                [f for f in active if len(active[f]) > 1],
                pretty=True,
                level=0)
        sys.exit(1)

    # flatten lists
    active = {f: active[f][0] for f in active}

    log('active files:', active, pretty=True, level=3)
    return active

def gen_fname(category, filename):
    return os.path.join(dotfiles, category), filename

def run_update(active_files):
    ops = FileOperations()

    for fname in active_files:
        categories = active_files[fname]

        files = {}
        links = {}
        master = None
        children = []

        for category in categories:
            full = os.path.join(*gen_fname(category, fname))
            if master is None:
                master = full
            else:
                children.append(full)
            links[full] = os.path.islink(full)
            files[full] = os.path.isfile(full) and not links[full]

        file_count = len([f for f in files if files[f]])
        link_count = len([f for f in links if links[f]])

        home_file = os.path.join(home, fname)
        # file_in_home: true if file lives in home/different from repo
        if args.hard:
            file_in_home = os.path.islink(home_file)
            file_in_home = not file_in_home and os.path.isfile(home_file)
        else:
            if os.path.islink(home_file):
                dotfiles_path = Path(os.path.realpath(dotfiles))
                home_path = Path(os.path.realpath(home_file))
                file_in_home = not dotfiles_path in home_path.parents
            else:
                file_in_home = os.path.isfile(home_file)

        if file_count == 0 and link_count == 0:
            if file_in_home:
                log(fname, 'new in repo from home', level=1)
                ops.home_move(home_file, master)
                ops.home_link(master, home_file)
                for c in children:
                    ops.link(master, c)
            else:
                log(fname, 'is not in your home dir or repo, skipping',
                        level=0)
        elif file_count == 1:
            # fix master if needed
            if links[master]:
                log('master incorrect but fixable, fixing')
                cfile = [f for f in children if not links[f]][0]
                ops.rm(master)
                ops.copy(cfile, master)

            # setup any child links
            for c in children:
                ops.link(master, c)

            if file_in_home:
                if args.hard:
                    if filecmp.cmp(master, home_file):
                        continue
                    r = False
                else:
                    r = prompt(fname + ' exists in in both the repo and home'
                            'dir, replace home version?')
                if r:
                    log('replacing home version of', fname, level=1)
                    ops.home_link(master, home_file)
                else:
                    log('replacing repo version of', fname, level=1)
                    ops.home_move(home_file, master)
                    if not args.hard:
                        ops.home_link(master, home_file)
            else:
                if not os.path.isfile(home_file):
                    log(fname, 'new from repo to home', level=1)
                ops.home_link(master, home_file)
        elif file_count > 1:
            pass
        elif link_count >= 1:
            pass
        else:
            log('unexpected file logic, please report an issue on github',
                    'with level 3 verbose output (re-run with -vvv)',
                    level=0)
            sys.exit(1)

    ops.run_operations()

if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    valid_actions = {
            'init',
            'update',
            'restore',
            'clean',
            'diff',
            }

    parser.add_argument('--verbose', '-v', action='count', default=0)
    parser.add_argument('--hard', action='store_true')
    parser.add_argument('--dry-run', '-n', action='store_true')
    parser.add_argument('action', choices=valid_actions)
    parser.add_argument('category', nargs='*',
            default=socket.gethostname())

    args = parser.parse_args()
    log('called with arguments:', vars(args))

    git = Git()

    if args.action == 'init':
        initialize_repo()
        sys.exit(0)

    # run safety checks before starting
    safety_checks()

    # parse filelist
    files, groups = parse_filelist(filelist)

    # determine active files
    files = active_files(files, args.category, groups)

    if args.action == 'update':
        run_update(files)
