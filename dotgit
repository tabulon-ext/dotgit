#!/usr/bin/env python3

import argparse
import os
import socket
import sys
import json
import subprocess

home = os.environ['HOME']
filelist = 'filelist'
dotfiles = 'dotfiles'

class Git:
    def __init__(self):
        pass

    def run(self, cmd):
        try:
            subprocess.run(cmd, check=True, capture_output=True)
        except subprocess.CalledProcessError as cp:
            log('command', cmd, 'failed, output:\n',
                    cp.stderr.decode(), level=0)
            sys.exit(1)

    def init(self):
        log('git initing')
        self.run(['git', 'init'])

    def add(self, fname):
        log('git adding', fname)
        self.run(['git', 'add', fname])

    def commit(self, msg):
        log('git committing "{}"'.format(msg))
        self.run(['git', 'commit', '-m', msg])

# level 0: errors
# level 1: informational
# level 2: debug
# level 3: variables
def log(*msg, level=2, pretty=False):
    global args

    # prettify dicts
    if pretty:
        msg = list(msg)
        for i in range(len(msg)):
            if type(msg[i]) in [dict, list]:
                msg[i] = json.dumps(msg[i], sort_keys=True, indent=1)

    if level == 0:
        print("ERROR:", *msg, file=sys.stderr)
    elif level <= args.verbose:
        print(*msg)

def initialize_repo():
    '''makes the current dir a dotgit repo'''

    log('initializing dotgit repo')

    git.init()
    with open(filelist, 'a') as f:
        pass

    git.add(filelist)
    git.commit('initial dotgit commit')

def safety_checks():
    '''runs various startup safety checks.

    will call sys.exit(1) if a problem is found.
    '''

    log('running safety checks')

    if os.getcwd() == home:
        log('refusing to run dotgit in your home directory, aborting', level=0)
        sys.exit(1)

    if not os.path.isdir('.git'):
        log('this does not appear to be a git repo, aborting', level=0)
        sys.exit(1)

    if not os.path.isfile(filelist):
        log('cannot find filelist, aborting', level=0)
        sys.exit(1)

    if not os.path.isdir(dotfiles):
        try:
            os.makedirs(dotfiles)
        except OSError:
            log('cannot create dotfiles directory, aborting', level=0)
            sys.exit(1)

def parse_filelist(flist):
    '''parses the filelist
    :param flist: the filelist path
    :returns: a tuple (files, groups)
    '''

    log('parsing filelist')

    files = {}
    groups = {}

    with open(flist, 'r') as f:
        lines = f.readlines()

        for line in lines:
            line = line.strip()
            if not line:
                continue
            if line.startswith('#'):
                continue

            if ':' in line:
                fname, cat = line.split(':')
                cat = sorted(cat.split(','))
                files[fname] = files.get(fname, []) + [cat]
            elif '=' in line:
                group, cat = line.split('=')
                cat = sorted(cat.split(','))
                groups[group] = cat
            else:
                files[line] = files.get(line, []) + [['common']]

    log('filelist', filelist, 'parsed')
    log('({}) files:'.format(filelist), files, pretty=True, level=4)
    log('({}) groups:'.format(filelist), groups, pretty=True, level=4)
    return files, groups

def active_files(files, selected, groups):
    """determines the active files

    :param files: all the files in the filelist
    :param selected: the selected categories as they come from the program
    arguments
    :param groups: the groups as defined in the filelist
    :returns: a dict of the active files
    """

    log('determining active files')

    if not type(selected) is list:
        selected = [selected]

    # expand groups
    selected = [groups.get(s, [s]) for s in selected]
    selected = [i for j in selected for i in j]

    # remove duplicates and make set
    selected = set(selected)

    # find intersection between selected and available categories
    active = {f: [c for c in files[f] if set(c) & selected] for f in files}

    # remove empty files (not selected)
    active = {f: active[f] for f in active if active[f]}

    # check for conflicting activated categories
    if sum([len(active[f])-1 for f in active]):
        log('conflicting categories for files activated, offending filenames:',
                [f for f in active if len(active[f]) > 1],
                pretty=True,
                level=0)
        sys.exit(1)

    # flatten lists
    active = {f: active[f][0] for f in active}

    log('active files:', active, pretty=True, level=4)
    return active

if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    valid_actions = {
            'init',
            'update',
            'restore',
            'clean',
            'diff',
            }

    # TODO: make the default value for verbose 0 again
    parser.add_argument('--verbose', '-v', action='count', default=4)
    parser.add_argument('--hard', action='store_true')
    parser.add_argument('action', choices=valid_actions)
    parser.add_argument('category', nargs='*',
            default=socket.gethostname())

    args = parser.parse_args()
    log('called with arguments:', vars(args))

    git = Git()

    if args.action == 'init':
        initialize_repo()
        sys.exit(0)

    # run safety checks before starting
    safety_checks()

    # parse filelist
    files, groups = parse_filelist(filelist)

    # determine active files
    files = active_files(files, args.category, groups)
